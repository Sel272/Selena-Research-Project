<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Research Project - Clustering</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Clustering/clustering.html">Clustering</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="../index.html" class="sidebar-logo-link">
      <img src="../Image/georgetown logo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../About/About.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About Me</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Introduction/Introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Project Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="https://github.com/Sel272/Selena-Research-Project" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Code</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Data/data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../DataGathering/datagathering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Gathering</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../DataCleaning/datacleaning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Cleaning</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../DataExploration/dataexploration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Exploration</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../NaiveBayes/naivebayes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Na√Øve Bayes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Clustering/clustering.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Clustering</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../DimensionalityReduction/dimensionalityreduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Dimensionality Reduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../DecisionTrees/decisiontrees.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Decision Trees</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Conclusions/conclusions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Conclusions</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#theories" id="toc-theories" class="nav-link" data-scroll-target="#theories">Theories</a>
  <ul class="collapse">
  <li><a href="#k-means-clustering" id="toc-k-means-clustering" class="nav-link" data-scroll-target="#k-means-clustering">K-Means Clustering</a></li>
  <li><a href="#dbscan-density-based-spatial-clustering-of-applications-with-noise" id="toc-dbscan-density-based-spatial-clustering-of-applications-with-noise" class="nav-link" data-scroll-target="#dbscan-density-based-spatial-clustering-of-applications-with-noise">DBSCAN (Density-Based Spatial Clustering of Applications with Noise)</a></li>
  <li><a href="#hierarchical-clustering" id="toc-hierarchical-clustering" class="nav-link" data-scroll-target="#hierarchical-clustering">Hierarchical Clustering</a></li>
  <li><a href="#model-selection-methods" id="toc-model-selection-methods" class="nav-link" data-scroll-target="#model-selection-methods">Model Selection Methods</a></li>
  </ul></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#data-selection" id="toc-data-selection" class="nav-link" data-scroll-target="#data-selection">Data Selection</a></li>
  <li><a href="#hyper-parameter-tuning" id="toc-hyper-parameter-tuning" class="nav-link" data-scroll-target="#hyper-parameter-tuning">Hyper-parameter tuning</a></li>
  <li><a href="#final-results" id="toc-final-results" class="nav-link" data-scroll-target="#final-results">Final Results</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a>
  <ul class="collapse">
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Clustering</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The ‚ÄòCardio‚Äô dataset comprises 12 features; however, for clustering purposes, only the numerical variables are pertinent. Therefore, I extracted the continuous variables to form a subset, denoted as the feature dataset X, from the original data. This curated dataset is utilized in the current project.</p>
<p>The objective is to employ clustering techniques to segment the dataset into distinct clusters, each representing unique cardiovascular traits. Each applied method will aim to maximize the difference between clusters. The resultant cluster groups will serve as a basis for analyzing varying levels of cardiovascular risk.</p>
<div id="a8ac1ac9" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>data<span class="op">=</span>pd.read_csv(<span class="st">'../Data/01-modified-data/cardiovascular_numeric_final.csv'</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> data.drop(data.columns[<span class="dv">0</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>numerical_cols <span class="op">=</span> [<span class="st">"age"</span>, <span class="st">"height"</span>, <span class="st">"weight"</span>, <span class="st">"ap_hi"</span>, <span class="st">"ap_lo"</span>, <span class="st">"bmi"</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> data[numerical_cols]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> data[<span class="st">'cardio'</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>X.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>Index(['age', 'height', 'weight', 'ap_hi', 'ap_lo', 'bmi'], dtype='object')</code></pre>
</div>
</div>
</section>
<section id="theories" class="level2">
<h2 class="anchored" data-anchor-id="theories">Theories</h2>
<section id="k-means-clustering" class="level3">
<h3 class="anchored" data-anchor-id="k-means-clustering">K-Means Clustering</h3>
<p>K-means is a commonly used clustering algorithm based on Euclidean distance and is a typical example of an unsupervised learning technique that does not require a labeled response. When using the K-Means algorithm, it should be noted that the number of clusters, k, is a hyperparameter and requires human input to determine. The main purpose is to find k optimal centroids based on the set K and to assign the data points closest to these centroids to the clusters represented by these centroids.</p>
<p>K-means clustering is widely and popularly used for cluster analysis because it is easy to interpret and implement, and the classification is effective. Even with a large number of variables, K-means can be computationally faster if a small k value is chosen. However, its accuracy may not be as high as that of supervised learning techniques, and it is also more sensitive to the choice of the k value. Moreover, it is not suitable for non-linear data.</p>
</section>
<section id="dbscan-density-based-spatial-clustering-of-applications-with-noise" class="level3">
<h3 class="anchored" data-anchor-id="dbscan-density-based-spatial-clustering-of-applications-with-noise">DBSCAN (Density-Based Spatial Clustering of Applications with Noise)</h3>
<p>The Density-Based Spatial Clustering of Applications with Noise (DBSCAN) is one of the most common clustering algorithms that identifies clusters based on the density of data points in a space. It operates by pinpointing areas where data points are closely grouped, thereby indicating that they are neighbors. Additionally, it can be used to identify non-linearly separable clusters and to mark outlier points that are situated alone in low-density regions.</p>
<p>Compared to the traditional K-Means algorithm, the most significant difference with DBSCAN is that it does not require the input of the number of clusters, k. It can also detect noise, effectively separating it from the clusters. However, a disadvantage of DBSCAN is its sensitivity to the choice of the ‚ÄòEps‚Äô and ‚ÄòMinPts‚Äô parameters.</p>
</section>
<section id="hierarchical-clustering" class="level3">
<h3 class="anchored" data-anchor-id="hierarchical-clustering">Hierarchical Clustering</h3>
<p>Hierarchical clustering is a technique in cluster analysis designed to create a nested series of clusters organized hierarchically. Compared to the other two methods, Hierarchical clustering can generate a dendrogram, which allows for the visualization of different clustering results and the similarity relationships among data points.</p>
<p>Agglomerative clustering is the most widely used type of Hierarchical clustering for grouping objects based on their similarity. This process begins with a single cluster encompassing all data points and gradually divides it into distinct clusters using various linkage methods. The process can be visualized through a dendrogram, and the optimal number of clusters can be chosen based on these visual results.</p>
<p>Like DBSCAN, Hierarchical clustering does not require a predetermined number of clusters. Its advantage lies in the use of a dendrogram for enhanced visualization.</p>
</section>
<section id="model-selection-methods" class="level3">
<h3 class="anchored" data-anchor-id="model-selection-methods">Model Selection Methods</h3>
<ul>
<li><p>Elbow Method: This method is used to find the optimal k value by plotting the within-cluster sum of squares (WCSS) against the number of clusters on a graph. The point where the WCSS begins to diminish, known as the ‚Äòelbow,‚Äô is considered an indicator of the appropriate number of clusters. When k equals 1, the WCSS value is at its largest. This method is mostly used in K-means clustering.</p></li>
<li><p>Silhouette Score: This metric evaluates the distance of a point to its own cluster in comparison to its distance to other clusters. The higher the score, the greater the separation between different clusters. Values range from -1 to 1, indicating poor, uncertain, and good clustering results, respectively. In essence, this measure ensures that each cluster is distinct and its members are more closely related to their own cluster than to others. The silhouette score, or silhouette coefficient, plays a crucial role in fine-tuning the hyperparameters in clustering algorithms such as DBSCAN and hierarchical clustering.</p></li>
</ul>
</section>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<section id="data-selection" class="level3">
<h3 class="anchored" data-anchor-id="data-selection">Data Selection</h3>
<p>The labels (targets) Y is not used when I did the data selection for the clustering.</p>
<div id="78d27ab3" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>data<span class="op">=</span>pd.read_csv(<span class="st">'../Data/01-modified-data/cardiovascular_numeric_final.csv'</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> data.drop(data.columns[<span class="dv">0</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>numerical_cols <span class="op">=</span> [<span class="st">"age"</span>, <span class="st">"height"</span>, <span class="st">"weight"</span>, <span class="st">"ap_hi"</span>, <span class="st">"ap_lo"</span>, <span class="st">"bmi"</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> data[numerical_cols]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> data[<span class="st">'cardio'</span>]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>       age  height  weight  ap_hi  ap_lo    bmi
0       50     168      62    110     80  21.97
1       55     156      85    140     90  34.93
2       52     165      64    130     70  23.51
3       48     169      82    150    100  28.71
4       48     156      56    100     60  23.01
...    ...     ...     ...    ...    ...    ...
64801   54     172      70    130     90  23.66
64802   58     165      80    150     80  29.38
64803   53     168      76    120     80  26.93
64804   61     163      72    135     80  27.10
64805   56     170      72    120     80  24.91

[64806 rows x 6 columns]</code></pre>
</div>
</div>
</section>
<section id="hyper-parameter-tuning" class="level3">
<h3 class="anchored" data-anchor-id="hyper-parameter-tuning">Hyper-parameter tuning</h3>
<p>Hyperparameter tuning is a crucial step in optimizing clustering algorithms to achieve the best performance. The following hyperparameters are used in the project:</p>
<section id="k-means" class="level4">
<h4 class="anchored" data-anchor-id="k-means">K-Means</h4>
<p>In K-means clustering analysis, the key parameter to adjust is the number of clusters, denoted as ‚Äòk.‚Äô One of the primary methods for tuning this parameter is the elbow method. This involves plotting ‚Äòk‚Äô against measures of Inertia and Distortion to visually determine the optimal number of clusters. The ‚Äòelbow‚Äô point‚Äîwhere the rate of decrease in both Inertia and Distortion sharply changes‚Äîindicates the most appropriate value for ‚Äòk.‚Äô This insight is typically gained during the hyper-parameter tuning stage.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Clustering/kmeans_hype.png" class="img-fluid figure-img"></p>
<figcaption>K-Means</figcaption>
</figure>
</div>
<p>The graph indicates that the optimal number of clusters is three. This conclusion is drawn from the observation that the reduction in Inertia and Distortion is less pronounced when moving from one to two clusters than it is from two to three clusters. According to the elbow method‚Äôs criteria, this suggests a ‚Äòk‚Äô value of three, where the rate of decrease in these metrics noticeably slows, signifying the most suitable cluster count.</p>
</section>
<section id="dbscan" class="level4">
<h4 class="anchored" data-anchor-id="dbscan">DBSCAN</h4>
<p>In DBSCAN modeling, the parameters ‚Äòeps‚Äô and ‚Äòmin_samples‚Äô require careful tuning. The ‚Äòeps‚Äô refers to epsilon, a critical parameter defining the maximum distance between two points for them to be categorized as part of the same neighborhood. On the other hand, ‚Äòmin_samples‚Äô represents the minimum number of samples required for a cluster to be defined. For ‚Äòeps,‚Äô the tested range includes values such as 0.1, 0.2, 0.3, 0.4, and 0.5. For ‚Äòmin_samples,‚Äô the range spans from 100, 1000, and 5000. Given the extensive size of the dataset, exhaustive tuning across a broad spectrum of values is impractical due to the significant time investment it would require. Consequently, a narrower selection of candidate values is explored. The silhouette score, a measure of cluster cohesion and separation, guides the tuning of DBSCAN parameters. The optimal parameters are identified by the peak silhouette score. The ensuing graph showcases the results from this parameter tuning exercise.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Clustering/DBSCAN_hype.png" class="img-fluid figure-img"></p>
<figcaption>DBSCAN</figcaption>
</figure>
</div>
<p>From the graph above, the highest silhouette score occurs when the number of clusters is 1. However, a cluster number of one implies that all data points are in a single cluster, which is not desirable. Therefore, the optimal number of clusters is identified as three, which yields the second-highest silhouette score. The accompanying table, detailing metrics for each ‚Äòeps‚Äô and ‚Äòmin_samples‚Äô configuration, indicates that the optimal ‚Äòeps‚Äô is 0.5 and the optimal ‚Äòmin_samples‚Äô is 100. This combination results in an ideal cluster count of three.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Clustering/DBSCAN_tab.png" class="img-fluid figure-img"></p>
<figcaption>DBSCAN Table</figcaption>
</figure>
</div>
</section>
<section id="hierarchical-clustering-1" class="level4">
<h4 class="anchored" data-anchor-id="hierarchical-clustering-1">Hierarchical Clustering</h4>
<p>The parameters to tune include the optimal number of clusters used to split the dendrogram and the linkage criterion, which defines the rule for measuring the distance between clusters. The dendrogram and silhouette score are common methods used in hierarchical clustering.</p>
<p><u>Linkage Criterion or Distance Metrics</u></p>
<p>Different clustering algorithms can use various distance metrics, and the choice of metric can significantly influence the clusters that are formed. For example,</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Clustering/Hierarchicalcluster.png" class="img-fluid figure-img"></p>
<figcaption>Hierarchical Clustering</figcaption>
</figure>
</div>
<ol class="example" type="1">
<li><p>Euclidean Distance measures the straight-line distance between two points in multidimensional space, calculated as the square root of the sum of the squared differences between the points‚Äô coordinates.</p></li>
<li><p>Manhattan Distance calculates the distance between two points by summing the absolute differences of their Cartesian coordinates.</p></li>
<li><p>Cosine similarity gauges the similarity of two points, focusing on direction rather than magnitude, useful in text analysis and high-dimensional spaces.</p></li>
<li><p>In Hierarchical clustering, the correlation distance (one minus the Pearson correlation coefficient) can be used to determine the similarity between two points.</p></li>
</ol>
<p>By carefully tuning parameters and choosing the right distance metric, one can greatly enhance the quality of clustering results. The Hierarchical clustering plot suggests choosing Manhattan distance as the optimal metric because it delivers the highest value among all considered metrics. However, the Manhattan distance does not produce clear results when visualized with a dendrogram. Thus, I have ultimately selected the Euclidean distance for the dendrogram, while Manhattan distance was used to achieve optimal Hierarchical clustering. The ideal number of clusters, determined by the highest silhouette value, is 2.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Clustering/Dendrogram_Eucli.png" class="img-fluid figure-img"></p>
<figcaption>Dendrogram</figcaption>
</figure>
</div>
</section>
</section>
<section id="final-results" class="level3">
<h3 class="anchored" data-anchor-id="final-results">Final Results</h3>
<p>In summary, I have reconstructed all the models, choosing 3 clusters for K-means clustering, 3 for DBSCAN, and 2 for Hierarchical clustering. This decision was based on the elbow method previously used for K-means and silhouette analysis for DBSCAN and Hierarchical clustering.</p>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<table class="table">
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">Silhouette Score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>K-Means Clustering</td>
<td style="text-align: left;">0.2223</td>
</tr>
<tr class="even">
<td>DBSCAN</td>
<td style="text-align: left;">-0.1371</td>
</tr>
<tr class="odd">
<td>Hierarchical Clustering</td>
<td style="text-align: left;">0.3090</td>
</tr>
</tbody>
</table>
<p>According to the final results table, the silhouette score for Hierarchical clustering is the highest at 0.3090, compared to the other two methods. The higher the silhouette score, the better the clustering results. However, since the value is still relatively low, it does not provide substantial insight into the analysis. Further investigation is required. The number of optimal clusters is close among the three methods, with K-means at 3, DBSCAN at 3, and Hierarchical clustering at 2. Due to the different algorithms and the nature of each method, there will be a small variance in the optimal cluster numbers. Overall, the results align with one another.</p>
<div>

</div>
<div id="Clusterings" class="quarto-layout-panel" data-layout-ncol="3">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Clustering/kmeancluster.png" class="img-fluid figure-img"></p>
<figcaption>2D Visualization</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="../Image/Clustering/DBSCANcluster.png" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="../Image/Clustering/Hierarcluster.png" class="img-fluid"></p>
</div>
</div>
</div>
<p>Based on the analysis of the three plots, the K-means clustering plot appears to be the most effective.Overall, the number of clusters matches between different methods, but the data points within each group vary significantly from one method to another. The scatter plot clearly visualizes the data points and their assigned cluster labels, showcasing distinct grouping patterns and separation between clusters, allowing for the identification of three distinct groups.</p>
<p>In contrast, the silhouette score for DBSCAN is negative, indicating it is an unsuitable choice. Furthermore, the scatter plot for DBSCAN divides the data into three clusters and one noise cluster, offering no clear visual conclusions. In the Hierarchical clustering plot, the data points are divided into two groups, but one group contains only a single value, rendering it indistinct in the visualization. This essentially equates to dividing the entire dataset into a single cluster, which does not meet our expectations, despite it having the highest silhouette score among the three.</p>
<p>Therefore, K-means emerges as the more reasonable option, with a clearer division of clusters and a comparatively high silhouette score, making it the optimal model. Additionally, the labels could reflect three categories‚Äîhigh, medium, and low cardiovascular risk‚Äîrather than a binary distinction of cardiovascular disease presence.</p>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<p><img src="../Image/Clustering/silhouette_analysis_kmeans_2clusters.png" class="img-fluid"></p>
<p><img src="../Image/Clustering/silhouette_analysis_kmeans_3clusters.png" class="img-fluid"></p>
<p>In conclusion, the optimal clustering algorithm for the dataset appears to be the K-means method. It achieves relatively better scoring measures compared to others and effectively divides the data into distinct groups based on visualization.</p>
<p>A crucial aspect of using K-means or any other clustering method is determining the true labels for each cluster group. Since clustering is an unsupervised method, true labels are not known for unseen testing data. Even though true labels are available in this dataset and can be used to evaluate the results, it is still impractical to assign specific labels such as ‚Äúcardiovascular‚Äù or ‚Äúnon-cardiovascular‚Äù to any particular cluster. Moreover, the accompanying graph suggests a pattern that may justify dividing the dataset into three risk categories‚Äîhigh, medium, and low‚Äîwhen setting the number of clusters to three. This introduces an additional layer of complexity in defining group characteristics as the number of clusters increases. Additional data would be required for more accurate labeling of each group.</p>
<p>Furthermore, the measurement scores are not high for any of the three clustering methods, indicating limited practical utility for these clustering techniques. Future research may benefit from a supervised approach to directly predict labels, which could be a more effective modeling method for the current research objectives.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>In the cluster analysis of the ‚Äòcardio‚Äô dataset, I chose to work with 10% of the full dataset for Hierarchical clustering due to the algorithm‚Äôs time-intensive nature, which might introduce a selection bias. In the final results, ‚Äòbmi‚Äô and ‚Äòap_hi‚Äô were selected as variables for visualizing the 2D clustering. ‚ÄòBmi‚Äô effectively encapsulates information on both weight and height, while ‚Äòap_hi‚Äô serves as a reliable indicator of systolic blood pressure, making them informative dimensions for interpretation.</p>
</div>
</div>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">References</h3>
<div id="refs" role="list">
<ul>
<li>DSAN 5000 class notes and sample codes</li>
<li><span class="class" data-key="val"><em>https://www.displayr.com/understanding-cluster-analysis-a-comprehensive-guide/#common-mistakes-and-disadvantages-with-cluster-analysis</em></span></li>
</ul>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>