<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Research Project - Decision Trees</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../DecisionTrees/decisiontrees.html">Decision Trees</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="../index.html" class="sidebar-logo-link">
      <img src="../Image/georgetown logo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../About/About.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About Me</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Introduction/Introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Project Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="https://github.com/Sel272/Selena-Research-Project" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Code</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Data/data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../DataGathering/datagathering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Gathering</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../DataCleaning/datacleaning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Cleaning</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../DataExploration/dataexploration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Exploration</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../NaiveBayes/naivebayes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Naïve Bayes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Clustering/clustering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Clustering</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../DimensionalityReduction/dimensionalityreduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Dimensionality Reduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../DecisionTrees/decisiontrees.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Decision Trees</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Conclusions/conclusions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Conclusions</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#decision-tree" id="toc-decision-tree" class="nav-link" data-scroll-target="#decision-tree">Decision Tree</a>
  <ul class="collapse">
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a></li>
  <li><a href="#class-distribution" id="toc-class-distribution" class="nav-link" data-scroll-target="#class-distribution">Class Distribution</a></li>
  <li><a href="#baseline-model-for-comparison" id="toc-baseline-model-for-comparison" class="nav-link" data-scroll-target="#baseline-model-for-comparison">Baseline Model for Comparison</a></li>
  <li><a href="#features-selection-optional" id="toc-features-selection-optional" class="nav-link" data-scroll-target="#features-selection-optional">Features Selection (optional)</a></li>
  <li><a href="#model-tuning" id="toc-model-tuning" class="nav-link" data-scroll-target="#model-tuning">Model Tuning</a></li>
  <li><a href="#final-results" id="toc-final-results" class="nav-link" data-scroll-target="#final-results">Final Results</a></li>
  </ul></li>
  <li><a href="#random-forest" id="toc-random-forest" class="nav-link" data-scroll-target="#random-forest">Random Forest</a>
  <ul class="collapse">
  <li><a href="#methods-1" id="toc-methods-1" class="nav-link" data-scroll-target="#methods-1">Methods</a></li>
  <li><a href="#class-distribution-1" id="toc-class-distribution-1" class="nav-link" data-scroll-target="#class-distribution-1">Class Distribution</a></li>
  <li><a href="#baseline-model-for-comparison-1" id="toc-baseline-model-for-comparison-1" class="nav-link" data-scroll-target="#baseline-model-for-comparison-1">Baseline Model for Comparison</a></li>
  <li><a href="#features-selection-optional-1" id="toc-features-selection-optional-1" class="nav-link" data-scroll-target="#features-selection-optional-1">Features Selection (optional)</a></li>
  <li><a href="#model-tuning-1" id="toc-model-tuning-1" class="nav-link" data-scroll-target="#model-tuning-1">Model Tuning</a></li>
  <li><a href="#final-results-1" id="toc-final-results-1" class="nav-link" data-scroll-target="#final-results-1">Final Results</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Decision Trees</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>I apply an array of tree-based algorithms—Decision Trees (DT) and Random Forests—to unravel complex patterns within the cardiovascular dataset. Each method brings unique strengths: DTs for their clarity and ease of interpretation, Random Forests for their robustness and accuracy. Together, they form a comprehensive analytical approach that enhances the project’s predictive capabilities and provides insightful, data-driven decisions.</p>
<p>Applying a Decision Tree to cardiovascular datasets involves constructing a model that uses the data’s features to infer simple rules in a hierarchical structure, akin to a flowchart. This model excels in its interpretability, allowing medical practitioners to follow the logical progression of decisions leading to a diagnosis or prediction. It is particularly useful when the goal is to understand the decision-making process, such as identifying the risk factors that lead to heart disease.</p>
<p>Extending this approach, Random Forests aggregate the insights of numerous decision trees, thereby creating a ‘forest’ that is more robust and accurate. This ensemble method is especially powerful in cardiovascular studies due to its ability to handle large datasets with numerous variables, each contributing to the risk and progression of heart-related ailments. By harnessing the collective decision-making of multiple trees, Random Forests mitigate the overfitting issues prevalent in individual Decision Trees and offer a more nuanced understanding of the data.</p>
</section>
<section id="decision-tree" class="level1">
<h1>Decision Tree</h1>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<p>Decision Trees (DTs) stand out as a non-parametric supervised learning method, adept at both classification and regression. They aim to forge a model that predicts the value of a target variable through the learning of simple decision rules drawn from the features within the data. The method initiates at the root node, from where a multitude of paths diverge, each charting a course dictated by conditional rules. These paths culminate in the leaf nodes, which house the outcomes—the model’s predicted values—crafted through this insightful and systematic approach.</p>
<p>Using Decision Trees on the cardiovascular dataset is advantageous due to several key aspects of the algorithm that align well with the nature of medical data and the requirements of clinical decision-making processes.</p>
<p><u>Interpretability</u>: Medical professionals often prefer models that provide transparent reasoning for their predictions. Decision Trees offer clear visualizations of the path taken to reach a conclusion, resembling clinical decision charts that practitioners are accustomed to, thus facilitating easier validation and trust in the model’s predictions.</p>
<p><u>Handling Non-linear Relationships</u>: Cardiovascular data often involve complex, non-linear relationships between features and outcomes. Decision Trees can capture these non-linearities without the need for transformation of variables, as they recursively partition the space in a way that maximizes the separation of the classes or reduction of variance.</p>
<p><u>Feature Importance</u>: Decision Trees inherently perform feature selection by prioritizing splits on the most informative features. This can be particularly useful in a clinical setting to identify and rank risk factors that are most predictive of cardiovascular events.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Why Decision Trees?">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why Decision Trees?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Interpretable: They mimic human decision-making better than many other algorithms, making their decisions easy to understand.</li>
<li>Versatile: Capable of performing both classification and regression, they can handle a variety of data types.</li>
<li>Non-Parametric: They make no assumptions about the distribution of data, making them a robust option for real-world data.</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The methodology for applying Decision Trees to a cardiovascular dataset involves several key steps:
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ol class="example" type="1">
<li>Data Preprocessing: This includes cleaning the data, handling missing values, encoding categorical variables, and normalizing or standardizing numerical features if necessary.</li>
<li>Feature Engineering: New features, such as Body Mass Index (BMI), could be derived from existing data to provide additional insight into the patient’s health status.</li>
<li>Model Construction: A Decision Tree model is built using the preprocessed data, where the algorithm iteratively splits the data into subsets based on certain criteria, aiming to maximize the homogeneity of the target variable within each subset.</li>
<li>Model Tuning: Parameters such as tree depth, minimum samples per leaf, and splitting criteria are tuned to optimize model performance and prevent overfitting.</li>
<li>Validation: The model’s performance is assessed using appropriate metrics like accuracy, precision, recall, and the area under the ROC curve for classification tasks or mean squared error for regression.</li>
<li>Interpretation: The resulting tree is analyzed to understand the decision paths and rules it has learned, which features are most important for predictions, and how different feature values affect the outcome.</li>
</ol>
</div>
</div>
</div>
</section>
<section id="class-distribution" class="level2">
<h2 class="anchored" data-anchor-id="class-distribution">Class Distribution</h2>
<div id="704a80b7" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>cardio<span class="op">=</span>pd.read_csv(<span class="st">'../Data/01-modified-data/cardiovascular_numeric_final.csv'</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>count0 <span class="op">=</span> <span class="bu">len</span>(cardio[cardio[<span class="st">'cardio'</span>] <span class="op">==</span> <span class="dv">0</span>])</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>count1 <span class="op">=</span> <span class="bu">len</span>(cardio[cardio[<span class="st">'cardio'</span>] <span class="op">==</span> <span class="dv">1</span>])</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>total <span class="op">=</span> count0  <span class="op">+</span> count1  </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>prop1 <span class="op">=</span> count0  <span class="op">/</span> total</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>prop2 <span class="op">=</span> count1 <span class="op">/</span> total</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of points with cardio=0:"</span>, count0, prop1)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Number of points with cardio=1:"</span>, count1, prop2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Number of points with cardio=0: 33577 0.5181156065796377
Number of points with cardio=1: 31229 0.4818843934203623</code></pre>
</div>
</div>
<p>From the code above, there are 31,229 data records labeled as cardiovascular disease, and for non-cardiovascular disease, there are 33,557 records. The split is approximately 1:1, which guarantees a large number of data points for each class label. When splitting the dataset, attention must be paid to maintain a similar balance between the two classes to ensure an effective training and test data split.</p>
</section>
<section id="baseline-model-for-comparison" class="level2">
<h2 class="anchored" data-anchor-id="baseline-model-for-comparison">Baseline Model for Comparison</h2>
<div id="c740d360" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Baseline Random Classifier</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> accuracy_score</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> precision_recall_fscore_support</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>df<span class="op">=</span>pd.read_csv(<span class="st">'../Data/01-modified-data/cardiovascular_numeric_final.csv'</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>Y<span class="op">=</span>df[[<span class="st">'cardio'</span>]]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">12</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># RANDOM CLASSIFIER </span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> random_classifier(y_data):</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    ypred<span class="op">=</span>[]<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    max_label<span class="op">=</span>np.<span class="bu">max</span>(y_data)<span class="op">;</span> <span class="co">#print(max_label)</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>,<span class="bu">len</span>(y_data)):</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        ypred.append(<span class="bu">int</span>(np.floor((max_label<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span>np.random.uniform(<span class="dv">0</span>,<span class="dv">1</span>))))</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-----RANDOM CLASSIFIER-----"</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"count of prediction:"</span>,Counter(ypred).values()) <span class="co"># counts the elements' frequency</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"probability of prediction:"</span>,np.fromiter(Counter(ypred).values(), dtype<span class="op">=</span><span class="bu">float</span>)<span class="op">/</span><span class="bu">len</span>(y_data)) <span class="co"># counts the elements' frequency</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"accuracy"</span>,accuracy_score(y_data, ypred))</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"percision, recall, fscore,"</span>,precision_recall_fscore_support(y_data, ypred))</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">BINARY CLASS: UNIFORM LOAD"</span>)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>y<span class="op">=</span>Y</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>random_classifier(y)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">BINARY CLASS: NON UNIFORM LOAD"</span>)</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>y<span class="op">=</span>Y</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>random_classifier(y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
BINARY CLASS: UNIFORM LOAD
-----RANDOM CLASSIFIER-----
count of prediction: dict_values([32479, 32327])
probability of prediction: [0.50117273 0.49882727]
accuracy 0.49902786779001945
percision, recall, fscore, (array([0.51710336, 0.48086739]), array([0.50019358, 0.4977745 ]), array([0.50850793, 0.4891749 ]), array([33577, 31229]))

BINARY CLASS: NON UNIFORM LOAD
-----RANDOM CLASSIFIER-----
count of prediction: dict_values([32371, 32435])
probability of prediction: [0.49950622 0.50049378]
accuracy 0.5042742955899145
percision, recall, fscore, (array([0.52241204, 0.48617234]), array([0.50364833, 0.50494732]), array([0.51285862, 0.49538201]), array([33577, 31229]))</code></pre>
</div>
</div>
<p>A random classifier randomly picks either 1 or 0 as the predicted number, resulting in an accuracy of around 50%, as expected, due to the binary outcome. It could serve as the baseline model because all machine learning models should surpass random guessing. The machine learning model must discern patterns from the training data to predict outcomes for the test data. Random guessing does not incorporate any information from the training data and thus performs the worst among all models. When comparing tree models and random forest models, metrics such as accuracy, recall, and precision should all outperform the baseline model.</p>
</section>
<section id="features-selection-optional" class="level2">
<h2 class="anchored" data-anchor-id="features-selection-optional">Features Selection (optional)</h2>
<p>For feature selection, as there are only 12 feature variables in the dataset, all features have been retained to train the tree model and preserve the maximum amount of information.</p>
</section>
<section id="model-tuning" class="level2">
<h2 class="anchored" data-anchor-id="model-tuning">Model Tuning</h2>
<p>One of the most importan parameters for the tree model is the ‘max_depth’ parameter. It controls how many splits a tree model could make. If ‘max_depth’ is set too high, the training tree model will make as many splits as possible and try to perfectly fit the training data. It will potentially lead to overfitting whch is a notable issue of using tree model. Therefore, hyperparameter tuning process is conducted on this ‘max_depth’ variable for constructing the tree model.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/dt_tuning_1.png" class="img-fluid figure-img"></p>
<figcaption>Accuracy</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/dt_tuning_2.png" class="img-fluid figure-img"></p>
<figcaption>Recall</figcaption>
</figure>
</div>
<p>From the above graphs, the best test accuracies are achieved when ‘max_depth’ is between 4 and 7. This range is reasonable as it not only attains high test accuracy but also maintains a decent level of interpretability for the tree model. Given the nature of this research, which prioritizes the correct prediction of all cardiovascular diseases, it is crucial to minimize false negatives and, hence, maximize recall. The recall graph indicates that the best recall is obtained when ‘max_depth’ is set to 4. Therefore, as a result of hyperparameter tuning, the ‘max_depth’ for the final tree model is established at 4.</p>
</section>
<section id="final-results" class="level2">
<h2 class="anchored" data-anchor-id="final-results">Final Results</h2>
<p>The final tree model is constructed with ‘max_depth’ set to 4. The statistics for the training and test data are shown as follows.</p>
<div>

</div>
<div id="Statistics" class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/dt_train.png" class="img-fluid figure-img"></p>
<figcaption>Training</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/dt_test.png" class="img-fluid figure-img"></p>
<figcaption>Test</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/dt_train_conf.png" class="img-fluid figure-img"></p>
<figcaption>Training</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/dt_test_conf.png" class="img-fluid figure-img"></p>
<figcaption>Test</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>For training data, the accuracy is at 0.7285 and the recall for Y = 1 is 0.7265 while for test data, the accuracy is at 0.7309 and the recall for Y = 1 is 0.7243. Overall, the performance is relatively strong, with an accuracy rate of over 70% for both the training and test data. Since the training and test data perform similarly, no overfitting issue is identified. From a recall perspective, the scores are also above 0.7, indicating that 70% of the true cardiovascular disease records are predicted correctly. This is a positive outcome, as the research goal focuses more on maximizing recall than precision.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/dt_tree.png" class="img-fluid figure-img"></p>
<figcaption>Tree Diagram</figcaption>
</figure>
</div>
<p>The tree diagram illustrates that the primary attributes influencing the decision-making process include ‘ap_hi’, ‘age’, ‘cholesterol’, ‘gluc’, ‘bmi’, and ‘ap_lo’. At the very top, the root node is represented by ‘ap_hi’, which suggests that it is perhaps the most significant factor in this particular dataset. This node splits the dataset into two distinct groups, forming the basis for further analysis. Following this, ‘ap_hi’ branches out into two paths leading to ‘age’ and another instance of ‘ap_hi’, which are then further divided into sub-nodes. These sub-nodes, which result from subsequent splits, are referred to as decision nodes. As the process continues, each decision node evaluates additional attributes, further refining the categorization until reaching a conclusion at the leaf nodes. Tree models are relatively easy to interpret. For instance, to interpret the leftmost node: if ‘ap_hi’ is less than or equal to 129.5, ‘age’ is less than or equal to 54.5, ‘cholesterol’ is less than or equal to 2.5, and ‘age’ is again less than or equal to 45, then the class is predicted to be 0, indicating non-cardiovascular disease. This logic is reasonable because if an individual is younger with lower levels of cholesterol and blood pressure, it typically suggests that the person is healthier and in better shape, thus having a lower risk of developing cardiovascular disease.</p>
</section>
</section>
<section id="random-forest" class="level1">
<h1>Random Forest</h1>
<section id="methods-1" class="level2">
<h2 class="anchored" data-anchor-id="methods-1">Methods</h2>
<p>The Random Forest method is a type of ensemble learning technique, particularly useful for classification and regression tasks. The method operates by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees. Random Forests belong to the broader class of ensemble methods which operate by building multiple models and aggregating their predictions.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Features of Random Forest:
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ol type="1">
<li>Ensemble of Decision Trees: It combines the predictions from multiple decision tree models to produce a more accurate and stable prediction than any individual tree.</li>
<li>Randomness: When building trees, each tree in a Random Forest is built from a sample drawn with replacement (i.e., a bootstrap sample) from the training set. Moreover, when splitting nodes, the selected features are chosen from a random subset of the features. This ensures diversity among the trees, which adds to the robustness of the model.</li>
<li>Reduction of Overfitting: Unlike single decision trees, which can be prone to overfitting, Random Forests mitigate this by averaging or ‘voting’ across the forest of trees, which tends to cancel out biases and variances.</li>
<li>Variable Importance: Random Forests have the ability to provide a measure of feature importance by observing how much prediction errors increase when data for that feature is permuted while all others are left unchanged.</li>
<li>Versatility: They can be used for both categorical and continuous inputs and outputs, and they inherently perform multiclass classification. Non-parametric Method: The Random Forest algorithm makes no underlying assumptions about the distribution of data.</li>
</ol>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Random Forest Algorithm Steps:
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ol type="1">
<li>Bootstrap Sampling: Select N random samples from the dataset with replacement to create a bootstrap dataset.</li>
<li>Tree Building:</li>
</ol>
<ul>
<li>Grow a decision tree from the bootstrap dataset. At each node:</li>
<li>Select a random subset of features.</li>
<li>Choose the best split among those features to partition the data. Split the node into child nodes.</li>
</ul>
<ol start="3" type="1">
<li>Repeat: Repeat steps 1 and 2 to create a predetermined number of trees, adding each new tree to the forest.</li>
<li>Aggregation:</li>
</ol>
<ul>
<li>For classification tasks, use majority voting from each decision tree.</li>
<li>For regression tasks, take the average prediction from all decision trees.</li>
</ul>
<ol start="5" type="1">
<li>Prediction: To predict new data, run the data through each tree in the forest and use the majority vote or average as the final prediction.</li>
</ol>
</div>
</div>
</div>
</section>
<section id="class-distribution-1" class="level2">
<h2 class="anchored" data-anchor-id="class-distribution-1">Class Distribution</h2>
<p><strong>Refer to the class distribution in the Decision Tree section for additional details.</strong></p>
</section>
<section id="baseline-model-for-comparison-1" class="level2">
<h2 class="anchored" data-anchor-id="baseline-model-for-comparison-1">Baseline Model for Comparison</h2>
<p><strong>Refer to the same baseline model in the Decision Tree section for additional details.</strong></p>
</section>
<section id="features-selection-optional-1" class="level2">
<h2 class="anchored" data-anchor-id="features-selection-optional-1">Features Selection (optional)</h2>
<p>In the context of Random Forest, a subset of features is selected when building each tree within the forest. Therefore, additional feature selection will not be conducted during the Random Forest model building process.</p>
</section>
<section id="model-tuning-1" class="level2">
<h2 class="anchored" data-anchor-id="model-tuning-1">Model Tuning</h2>
<p>During the model tuning phase for the Random Forest algorithm, I opted to adjust the parameters ‘max_depth’, ‘max_features’, and ‘n_estimators’. The parameter ‘max_depth’, also adjusted in the Decision Tree section, establishes the tree’s maximum depth. ‘max_features’ determines the number of features evaluated when identifying the optimal split during the tree’s training process. In a Random Forest, this parameter introduces an element of randomness to the model. Rather than selecting the best feature for each node split, it chooses from a random subset of features, which results in a variety of trees. The ‘n_estimators’ parameter indicates the number of trees within the Random Forest. This represents the ensemble’s size; typically, more trees enhance performance but extend the training duration.</p>
<p>The outcomes of the hyperparameter tuning are documented as follows.</p>
<div>

</div>
<div id="Parameters" class="quarto-layout-panel" data-layout-ncol="3">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="../Image/Decision_Tree/rf_p1.png" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="../Image/Decision_Tree/rf_p2.png" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="../Image/Decision_Tree/rf_p3.png" class="img-fluid"></p>
</div>
</div>
</div>
<p>Based on the aforementioned results, the parameters that yield the highest accuracies are {‘max_depth’: 8, ‘max_features’: 5, ‘n_estimators’: 200}. These parameters will be employed to construct the final Random Forest model.</p>
</section>
<section id="final-results-1" class="level2">
<h2 class="anchored" data-anchor-id="final-results-1">Final Results</h2>
<div>

</div>
<div id="Statistics" class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/rf_train.png" class="img-fluid figure-img"></p>
<figcaption>Train</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/rf_test.png" class="img-fluid figure-img"></p>
<figcaption>Test</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/rf_train_conf.png" class="img-fluid figure-img"></p>
<figcaption>Train</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/rf_test_conf.png" class="img-fluid figure-img"></p>
<figcaption>Test</figcaption>
</figure>
</div>
</div>
</div>
</div>
<p>For training data, the accuracy is at 0.7427 and the recall for Y = 1 is 0.6687 while for test data, the accuracy is at 0.7316 and the recall for Y = 1 is 0.6523. Overall, the performance is moderatly strong, with an accuracy rate of over 70% for both the training and test data. Since the training and test data perform similarly, no overfitting issue is identified. From a recall perspective, the scores are also above 0.65, indicating that 65% of the true cardiovascular disease records are predicted correctly. This is a positive outcome, as the research goal focuses more on maximizing recall than precision.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Image/Decision_Tree/rf_var.png" class="img-fluid figure-img"></p>
<figcaption>Variable</figcaption>
</figure>
</div>
<p>From the variable importance graph displayed above, ‘bmi’, ‘age’, ‘cholesterol’, ‘ap_lo’, and ‘ap_hi’ emerge as the top five most important variables in the Random Forest model building process. These results align with those obtained using other machine learning methods and also mirror the findings of the feature selection section discussed in previous segments. These key variables are crucial in relation to cardiovascular disease during the model training process for Random Forest and should receive more focus in future research endeavors.</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Overall, both the decision tree and random forest models performed well, achieving high accuracy and recall scores on the test data. The decision tree appears to be superior to the random forest model due to its higher recall score and the absence of any obvious overfitting pattern. Unlike the random forest, the decision tree maintains the advantage of easy interpretation. With its tree diagram, audiences can effortlessly analyze the prediction results by interpreting the outcomes along each branch and node. Additionally, the dataset does not contain an excessive number of features, which would necessitate a more sophisticated feature selection process. Although random forests are more adept at selecting key features and preventing overfitting compared to decision trees, these aspects are not the primary focus of this research project, given the dataset’s characteristics. Therefore, based on the stronger model performance and ease of interpretation, I will opt for the decision tree over the random forest in this instance.</p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<div id="refs" role="list">
<ul>
<li><span class="class" data-key="val"><em>https://www.analyticsvidhya.com/blog/2020/05/decision-tree-vs-random-forest-algorithm/#:~:text=A%20decision%20tree%20is%20more,%2C%20healthcare%2C%20and%20deep%20learning.</em></span></li>
</ul>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>